From 5364560da13f98306f33d6303f0a8b6e27a1bbfa Mon Sep 17 00:00:00 2001
From: must_eat <mss@tutanota.de>
Date: Thu, 7 Jul 2022 23:14:39 +0300
Subject: [PATCH 03/16] allow custom rust triplets.

---
 build/moz.configure/rust.configure            |   8 +-
 .../rust/target-lexicon-0.9.0/build.rs        |  23 ++-
 .../rust/target-lexicon-0.9.0/src/lib.rs      |   4 +-
 .../rust/target-lexicon-0.9.0/src/targets.rs  | 169 +++++++++++++++++-
 .../rust/target-lexicon-0.9.0/src/triple.rs   |   4 -
 5 files changed, 194 insertions(+), 14 deletions(-)

diff --git a/build/moz.configure/rust.configure b/build/moz.configure/rust.configure
index e64dc5d5ec..2134ed2fea 100644
--- a/build/moz.configure/rust.configure
+++ b/build/moz.configure/rust.configure
@@ -274,7 +274,9 @@ def rust_supported_targets(rustc):
         data.setdefault(key, []).append(namespace(rust_target=t, target=info))
     return data
 
-
+@imports('os')
+@imports(_from='mozbuild.util', _import='ensure_unicode')
+@imports(_from='mozbuild.util', _import='system_encoding')
 def detect_rustc_target(
     host_or_target, compiler_info, arm_target, rust_supported_targets
 ):
@@ -396,12 +398,12 @@ def detect_rustc_target(
 
         return None
 
-    rustc_target = find_candidate(candidates)
+    rustc_target = os.environ['RUST_TARGET']
 
     if rustc_target is None:
         die("Don't know how to translate {} for rustc".format(host_or_target.alias))
 
-    return rustc_target
+    return ensure_unicode(rustc_target, system_encoding)
 
 
 @imports("os")
diff --git a/third_party/rust/target-lexicon-0.9.0/build.rs b/third_party/rust/target-lexicon-0.9.0/build.rs
index a0ba3b7304..e88206e0b4 100644
--- a/third_party/rust/target-lexicon-0.9.0/build.rs
+++ b/third_party/rust/target-lexicon-0.9.0/build.rs
@@ -32,6 +32,7 @@ mod parse_error {
     }
 }
 
+use self::targets::Vendor;
 use self::triple::Triple;
 
 fn main() {
@@ -52,6 +53,8 @@ fn write_host_rs(mut out: File, triple: Triple) -> io::Result<()> {
     writeln!(out, "use crate::Aarch64Architecture::*;")?;
     writeln!(out, "#[allow(unused_imports)]")?;
     writeln!(out, "use crate::ArmArchitecture::*;")?;
+    writeln!(out, "#[allow(unused_imports)]")?;
+    writeln!(out, "use crate::CustomVendor;")?;
     writeln!(out)?;
     writeln!(out, "/// The `Triple` of the current host.")?;
     writeln!(out, "pub const HOST: Triple = Triple {{")?;
@@ -60,7 +63,7 @@ fn write_host_rs(mut out: File, triple: Triple) -> io::Result<()> {
         "    architecture: Architecture::{:?},",
         triple.architecture
     )?;
-    writeln!(out, "    vendor: Vendor::{:?},", triple.vendor)?;
+    writeln!(out, "    vendor: {},", vendor_display(&triple.vendor))?;
     writeln!(
         out,
         "    operating_system: OperatingSystem::{:?},",
@@ -90,7 +93,7 @@ fn write_host_rs(mut out: File, triple: Triple) -> io::Result<()> {
     writeln!(out, "impl Vendor {{")?;
     writeln!(out, "    /// Return the vendor for the current host.")?;
     writeln!(out, "    pub const fn host() -> Self {{")?;
-    writeln!(out, "        Vendor::{:?}", triple.vendor)?;
+    writeln!(out, "        {}", vendor_display(&triple.vendor))?;
     writeln!(out, "    }}")?;
     writeln!(out, "}}")?;
     writeln!(out)?;
@@ -138,7 +141,11 @@ fn write_host_rs(mut out: File, triple: Triple) -> io::Result<()> {
         "            architecture: Architecture::{:?},",
         triple.architecture
     )?;
-    writeln!(out, "            vendor: Vendor::{:?},", triple.vendor)?;
+    writeln!(
+        out,
+        "            vendor: {},",
+        vendor_display(&triple.vendor)
+    )?;
     writeln!(
         out,
         "            operating_system: OperatingSystem::{:?},",
@@ -160,3 +167,13 @@ fn write_host_rs(mut out: File, triple: Triple) -> io::Result<()> {
 
     Ok(())
 }
+
+fn vendor_display(vendor: &Vendor) -> String {
+    match vendor {
+        Vendor::Custom(custom) => format!(
+            "Vendor::Custom(CustomVendor::Static({:?}))",
+            custom.as_str()
+        ),
+        known => format!("Vendor::{:?}", known),
+    }
+}
diff --git a/third_party/rust/target-lexicon-0.9.0/src/lib.rs b/third_party/rust/target-lexicon-0.9.0/src/lib.rs
index 8d6da8dcfc..70f64886f3 100644
--- a/third_party/rust/target-lexicon-0.9.0/src/lib.rs
+++ b/third_party/rust/target-lexicon-0.9.0/src/lib.rs
@@ -28,7 +28,7 @@ mod triple;
 pub use self::host::HOST;
 pub use self::parse_error::ParseError;
 pub use self::targets::{
-    Aarch64Architecture, Architecture, ArmArchitecture, BinaryFormat, Environment, OperatingSystem,
-    Vendor,
+    Aarch64Architecture, Architecture, ArmArchitecture, BinaryFormat, CustomVendor, Environment,
+    OperatingSystem, Vendor,
 };
 pub use self::triple::{CallingConvention, Endianness, PointerWidth, Triple};
diff --git a/third_party/rust/target-lexicon-0.9.0/src/targets.rs b/third_party/rust/target-lexicon-0.9.0/src/targets.rs
index 6ae570ebe8..eb5a088f94 100644
--- a/third_party/rust/target-lexicon-0.9.0/src/targets.rs
+++ b/third_party/rust/target-lexicon-0.9.0/src/targets.rs
@@ -1,7 +1,10 @@
 // This file defines all the identifier enums and target-aware logic.
 
 use crate::triple::{Endianness, PointerWidth, Triple};
+use alloc::boxed::Box;
+use alloc::string::String;
 use core::fmt;
+use core::hash::{Hash, Hasher};
 use core::str::FromStr;
 
 /// The "architecture" field, which in some cases also specifies a specific
@@ -290,9 +293,42 @@ impl Aarch64Architecture {
     }
 }
 
+/// A string for a `Vendor::Custom` that can either be used in `const`
+/// contexts or hold dynamic strings.
+#[derive(Clone, Debug, Eq)]
+pub enum CustomVendor {
+    /// An owned `String`. This supports the general case.
+    Owned(Box<String>),
+    /// A static `str`, so that `CustomVendor` can be constructed in `const`
+    /// contexts.
+    Static(&'static str),
+}
+
+impl CustomVendor {
+    /// Extracts a string slice.
+    pub fn as_str(&self) -> &str {
+        match self {
+            CustomVendor::Owned(s) => s,
+            CustomVendor::Static(s) => s,
+        }
+    }
+}
+
+impl PartialEq for CustomVendor {
+    fn eq(&self, other: &Self) -> bool {
+        self.as_str() == other.as_str()
+    }
+}
+
+impl Hash for CustomVendor {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        self.as_str().hash(state)
+    }
+}
+
 /// The "vendor" field, which in practice is little more than an arbitrary
 /// modifier.
-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
+#[derive(Clone, Debug, PartialEq, Eq, Hash)]
 #[allow(missing_docs)]
 pub enum Vendor {
     Unknown,
@@ -306,6 +342,15 @@ pub enum Vendor {
     Sun,
     Uwp,
     Wrs,
+
+    /// A custom vendor. "Custom" in this context means that the vendor is
+    /// not specifically recognized by upstream Autotools, LLVM, Rust, or other
+    /// relevant authorities on triple naming. It's useful for people building
+    /// and using locally patched toolchains.
+    ///
+    /// Outside of such patched environments, users of `target-lexicon` should
+    /// treat `Custom` the same as `Unknown` and ignore the string.
+    Custom(CustomVendor),
 }
 
 /// The "operating system" field, which sometimes implies an environment, and
@@ -717,6 +762,7 @@ impl fmt::Display for Vendor {
             Vendor::Sun => "sun",
             Vendor::Uwp => "uwp",
             Vendor::Wrs => "wrs",
+            Vendor::Custom(ref name) => name.as_str(),
         };
         f.write_str(s)
     }
@@ -738,7 +784,43 @@ impl FromStr for Vendor {
             "sun" => Vendor::Sun,
             "uwp" => Vendor::Uwp,
             "wrs" => Vendor::Wrs,
-            _ => return Err(()),
+            custom => {
+                use alloc::borrow::ToOwned;
+
+                // A custom vendor. Since triple syntax is so loosely defined,
+                // be as conservative as we can to avoid potential ambiguities.
+                // We err on the side of being too strict here, as we can
+                // always relax it if needed.
+
+                // Don't allow empty string names.
+                if custom.is_empty() {
+                    return Err(());
+                }
+
+                // Don't allow any other recognized name as a custom vendor,
+                // since vendors can be omitted in some contexts.
+                if Architecture::from_str(custom).is_ok()
+                    || OperatingSystem::from_str(custom).is_ok()
+                    || Environment::from_str(custom).is_ok()
+                    || BinaryFormat::from_str(custom).is_ok()
+                {
+                    return Err(());
+                }
+
+                // Require the first character to be an ascii lowercase.
+                if !custom.chars().nth(0).unwrap().is_ascii_lowercase() {
+                    return Err(());
+                }
+
+                // Restrict the set of characters permitted in a custom vendor.
+                if custom.chars().any(|c: char| {
+                    !(c.is_ascii_lowercase() || c.is_ascii_digit() || c == '_' || c == '.')
+                }) {
+                    return Err(());
+                }
+
+                Vendor::Custom(CustomVendor::Owned(Box::new(custom.to_owned())))
+            }
         })
     }
 }
@@ -1120,4 +1202,87 @@ mod tests {
         assert_eq!(t.environment, Environment::Eabihf);
         assert_eq!(t.binary_format, BinaryFormat::Elf);
     }
+
+    #[test]
+    fn custom_vendors() {
+        // Test various invalid cases.
+        assert!(Triple::from_str("x86_64--linux").is_err());
+        assert!(Triple::from_str("x86_64-42-linux").is_err());
+        assert!(Triple::from_str("x86_64-__customvendor__-linux").is_err());
+        assert!(Triple::from_str("x86_64-^-linux").is_err());
+        assert!(Triple::from_str("x86_64- -linux").is_err());
+        assert!(Triple::from_str("x86_64-CustomVendor-linux").is_err());
+        assert!(Triple::from_str("x86_64-linux-linux").is_err());
+        assert!(Triple::from_str("x86_64-x86_64-linux").is_err());
+        assert!(Triple::from_str("x86_64-elf-linux").is_err());
+        assert!(Triple::from_str("x86_64-gnu-linux").is_err());
+        assert!(Triple::from_str("x86_64-linux-customvendor").is_err());
+        assert!(Triple::from_str("customvendor").is_err());
+        assert!(Triple::from_str("customvendor-x86_64").is_err());
+        assert!(Triple::from_str("x86_64-").is_err());
+        assert!(Triple::from_str("x86_64--").is_err());
+
+        // Test various Unicode things.
+        assert!(
+            Triple::from_str("x86_64-𝓬𝓾𝓼𝓽𝓸𝓶𝓿𝓮𝓷𝓭𝓸𝓻-linux").is_err(),
+            "unicode font hazard"
+        );
+        assert!(
+            Triple::from_str("x86_64-ćúśtőḿvéńdőŕ-linux").is_err(),
+            "diacritical mark stripping hazard"
+        );
+        assert!(
+            Triple::from_str("x86_64-customvendοr-linux").is_err(),
+            "homoglyph hazard"
+        );
+        assert!(Triple::from_str("x86_64-customvendor-linux").is_ok());
+        assert!(
+            Triple::from_str("x86_64-ﬃ-linux").is_err(),
+            "normalization hazard"
+        );
+        assert!(Triple::from_str("x86_64-ffi-linux").is_ok());
+        assert!(
+            Triple::from_str("x86_64-custom‍vendor-linux").is_err(),
+            "zero-width character hazard"
+        );
+        assert!(
+            Triple::from_str("x86_64-﻿customvendor-linux").is_err(),
+            "BOM hazard"
+        );
+
+        // Test some valid cases.
+        let t = Triple::from_str("x86_64-customvendor-linux")
+            .expect("can't parse target with custom vendor");
+        assert_eq!(t.architecture, Architecture::X86_64);
+        assert_eq!(
+            t.vendor,
+            Vendor::Custom(CustomVendor::Static("customvendor"))
+        );
+        assert_eq!(t.operating_system, OperatingSystem::Linux);
+        assert_eq!(t.environment, Environment::Unknown);
+        assert_eq!(t.binary_format, BinaryFormat::Elf);
+        assert_eq!(t.to_string(), "x86_64-customvendor-linux");
+
+        let t =
+            Triple::from_str("x86_64-customvendor").expect("can't parse target with custom vendor");
+        assert_eq!(t.architecture, Architecture::X86_64);
+        assert_eq!(
+            t.vendor,
+            Vendor::Custom(CustomVendor::Static("customvendor"))
+        );
+        assert_eq!(t.operating_system, OperatingSystem::Unknown);
+        assert_eq!(t.environment, Environment::Unknown);
+        assert_eq!(t.binary_format, BinaryFormat::Unknown);
+
+        assert_eq!(
+            Triple::from_str("unknown-foo"),
+            Ok(Triple {
+                architecture: Architecture::Unknown,
+                vendor: Vendor::Custom(CustomVendor::Static("foo")),
+                operating_system: OperatingSystem::Unknown,
+                environment: Environment::Unknown,
+                binary_format: BinaryFormat::Unknown,
+            })
+        );
+    }
 }
diff --git a/third_party/rust/target-lexicon-0.9.0/src/triple.rs b/third_party/rust/target-lexicon-0.9.0/src/triple.rs
index 36dcd9aa00..1abda2672f 100644
--- a/third_party/rust/target-lexicon-0.9.0/src/triple.rs
+++ b/third_party/rust/target-lexicon-0.9.0/src/triple.rs
@@ -322,10 +322,6 @@ mod tests {
             Triple::from_str("foo"),
             Err(ParseError::UnrecognizedArchitecture("foo".to_owned()))
         );
-        assert_eq!(
-            Triple::from_str("unknown-foo"),
-            Err(ParseError::UnrecognizedVendor("foo".to_owned()))
-        );
         assert_eq!(
             Triple::from_str("unknown-unknown-foo"),
             Err(ParseError::UnrecognizedOperatingSystem("foo".to_owned()))
-- 
2.37.0

