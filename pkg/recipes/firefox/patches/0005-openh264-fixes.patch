From a33235da53fb8c4160d7cc12d8f21a9edd1134d8 Mon Sep 17 00:00:00 2001
From: must_eat <mss@tutanota.de>
Date: Mon, 26 Sep 2022 10:12:01 +0300
Subject: [PATCH 05/15] openh264 fixes.

---
 dom/media/gmp/GMPSharedMemManager.h               |  2 +-
 dom/media/mp4/MP4Demuxer.cpp                      |  8 ++++++++
 dom/media/platforms/PDMFactory.cpp                | 15 ++++++++++-----
 dom/media/platforms/PDMFactory.h                  |  2 ++
 .../platforms/agnostic/gmp/GMPDecoderModule.cpp   |  1 +
 .../platforms/agnostic/gmp/GMPVideoDecoder.cpp    |  2 ++
 6 files changed, 24 insertions(+), 6 deletions(-)

diff --git a/dom/media/gmp/GMPSharedMemManager.h b/dom/media/gmp/GMPSharedMemManager.h
index ad4c3d39c2..1a04bdde14 100644
--- a/dom/media/gmp/GMPSharedMemManager.h
+++ b/dom/media/gmp/GMPSharedMemManager.h
@@ -26,7 +26,7 @@ class GMPSharedMem {
   // returned to the parent pool (which is not included).  If more than
   // this are needed, we presume the client has either crashed or hung
   // (perhaps temporarily).
-  static const uint32_t kGMPBufLimit = 20;
+  static const uint32_t kGMPBufLimit = 40;
 
   GMPSharedMem() {
     for (size_t i = 0; i < sizeof(mGmpAllocated) / sizeof(mGmpAllocated[0]);
diff --git a/dom/media/mp4/MP4Demuxer.cpp b/dom/media/mp4/MP4Demuxer.cpp
index 59bba16577..0304e3e89f 100644
--- a/dom/media/mp4/MP4Demuxer.cpp
+++ b/dom/media/mp4/MP4Demuxer.cpp
@@ -31,6 +31,8 @@ mozilla::LogModule* GetDemuxerLog() { return gMediaDemuxerLog; }
   DDMOZ_LOG(gMediaDemuxerLog, mozilla::LogLevel::Debug, "::%s: " arg, \
             __func__, ##__VA_ARGS__)
 
+extern bool gUseKeyframeFromContainer;
+
 namespace mozilla {
 
 DDLoggedTypeDeclNameAndBase(MP4TrackDemuxer, MediaTrackDemuxer);
@@ -394,6 +396,12 @@ already_AddRefed<MediaRawData> MP4TrackDemuxer::GetNextSample() {
           [[fallthrough]];
         case H264::FrameType::OTHER: {
           bool keyframe = type == H264::FrameType::I_FRAME;
+          if (gUseKeyframeFromContainer) {
+            if (sample->mKeyframe && sample->mKeyframe != keyframe) {
+              sample->mKeyframe = keyframe;
+            }
+            break;
+          }
           if (sample->mKeyframe != keyframe) {
             NS_WARNING(nsPrintfCString("Frame incorrectly marked as %skeyframe "
                                        "@ pts:%" PRId64 " dur:%" PRId64
diff --git a/dom/media/platforms/PDMFactory.cpp b/dom/media/platforms/PDMFactory.cpp
index 0f3fad38d8..bf3d81de9c 100644
--- a/dom/media/platforms/PDMFactory.cpp
+++ b/dom/media/platforms/PDMFactory.cpp
@@ -68,6 +68,8 @@ using MediaCodecsSupport = mozilla::media::MediaCodecsSupport;
 using MediaCodecsSupported = mozilla::media::MediaCodecsSupported;
 using MCSInfo = mozilla::media::MCSInfo;
 
+bool gUseKeyframeFromContainer = false;
+
 namespace mozilla {
 
 #define PDM_INIT_LOG(msg, ...) \
@@ -638,10 +640,12 @@ void PDMFactory::CreateContentPDMs() {
   }
 #endif
 #ifdef MOZ_FFMPEG
-  if (StaticPrefs::media_ffmpeg_enabled() &&
-      !CreateAndStartupPDM<FFmpegRuntimeLinker>()) {
-    mFailureFlags += GetFailureFlagBasedOnFFmpegStatus(
-        FFmpegRuntimeLinker::LinkStatusCode());
+  if (StaticPrefs::media_ffmpeg_enabled()) {
+    mFFmpegUsed = CreateAndStartupPDM<FFmpegRuntimeLinker>();
+    if (!mFFmpegUsed) {
+      mFailureFlags += GetFailureFlagBasedOnFFmpegStatus(
+          FFmpegRuntimeLinker::LinkStatusCode());
+    }
   }
 #endif
 #ifdef MOZ_WIDGET_ANDROID
@@ -653,8 +657,9 @@ void PDMFactory::CreateContentPDMs() {
 
   CreateAndStartupPDM<AgnosticDecoderModule>();
 
-  if (StaticPrefs::media_gmp_decoder_enabled() &&
+  if (StaticPrefs::media_gmp_decoder_enabled() && !mFFmpegUsed &&
       !CreateAndStartupPDM<GMPDecoderModule>()) {
+    gUseKeyframeFromContainer = true;
     mFailureFlags += DecoderDoctorDiagnostics::Flags::GMPPDMFailedToStartup;
   }
 }
diff --git a/dom/media/platforms/PDMFactory.h b/dom/media/platforms/PDMFactory.h
index 95b5df8a09..df039f2ba1 100644
--- a/dom/media/platforms/PDMFactory.h
+++ b/dom/media/platforms/PDMFactory.h
@@ -103,6 +103,8 @@ class PDMFactory final {
 
   DecoderDoctorDiagnostics::FlagsSet mFailureFlags;
 
+  bool mFFmpegUsed = false;
+
   friend class RemoteVideoDecoderParent;
   static void EnsureInit();
 };
diff --git a/dom/media/platforms/agnostic/gmp/GMPDecoderModule.cpp b/dom/media/platforms/agnostic/gmp/GMPDecoderModule.cpp
index dbf0d291c7..ccb247ed0c 100644
--- a/dom/media/platforms/agnostic/gmp/GMPDecoderModule.cpp
+++ b/dom/media/platforms/agnostic/gmp/GMPDecoderModule.cpp
@@ -66,6 +66,7 @@ media::DecodeSupportSet GMPDecoderModule::SupportsMimeType(
 
   nsCString api = nsLiteralCString(CHROMIUM_CDM_API);
 
+  // TODO: Do we enable it here?
   if (MP4Decoder::IsH264(aMimeType)) {
     isSupported = HaveGMPFor(api, {"h264"_ns, aGMP.value()});
   } else if (VPXDecoder::IsVP9(aMimeType)) {
diff --git a/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.cpp b/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.cpp
index d268a0a64b..bf6c7b6122 100644
--- a/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.cpp
+++ b/dom/media/platforms/agnostic/gmp/GMPVideoDecoder.cpp
@@ -70,6 +70,8 @@ void GMPVideoDecoder::Decoded(GMPVideoi420Frame* aDecodedFrame) {
   RefPtr<GMPVideoDecoder> self = this;
   if (v) {
     mDecodedData.AppendElement(std::move(v));
+    mDecodePromise.ResolveIfExists(std::move(mDecodedData), __func__);
+    mDecodedData = DecodedData();
   } else {
     mDecodedData.Clear();
     mDecodePromise.RejectIfExists(
-- 
2.37.1

