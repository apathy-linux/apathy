diff -uraN a/scripts/Makefile.build b/scripts/Makefile.build
--- a/scripts/Makefile.build	2022-08-01 00:03:01.000000000 +0300
+++ b/scripts/Makefile.build	2022-08-03 22:25:07.852992135 +0300
@@ -223,12 +223,9 @@
 	$(CONFIG_SHELL) $(srctree)/scripts/gen_ksymdeps.sh $@ >> $(dot-target).cmd
 endif
 
-cmd_check_local_export = $(srctree)/scripts/check-local-export $@
-
 define rule_cc_o_c
 	$(call cmd_and_fixdep,cc_o_c)
 	$(call cmd,gen_ksymdeps)
-	$(call cmd,check_local_export)
 	$(call cmd,checksrc)
 	$(call cmd,checkdoc)
 	$(call cmd,gen_objtooldep)
@@ -239,7 +236,6 @@
 define rule_as_o_S
 	$(call cmd_and_fixdep,as_o_S)
 	$(call cmd,gen_ksymdeps)
-	$(call cmd,check_local_export)
 	$(call cmd,gen_objtooldep)
 	$(call cmd,gen_symversions_S)
 endef
diff -uraN a/scripts/check-local-export b/scripts/check-local-export
--- a/scripts/check-local-export	2022-08-01 00:03:01.000000000 +0300
+++ b/scripts/check-local-export	1970-01-01 02:00:00.000000000 +0200
@@ -1,71 +0,0 @@
-#!/usr/bin/env bash
-# SPDX-License-Identifier: GPL-2.0-only
-#
-# Copyright (C) 2022 Masahiro Yamada <masahiroy@kernel.org>
-#
-# Exit with error if a local exported symbol is found.
-# EXPORT_SYMBOL should be used for global symbols.
-
-set -e
-
-# catch errors from ${NM}
-set -o pipefail
-
-# Run the last element of a pipeline in the current shell.
-# Without this, the while-loop would be executed in a subshell, and
-# the changes made to 'symbol_types' and 'export_symbols' would be lost.
-shopt -s lastpipe
-
-declare -A symbol_types
-declare -a export_symbols
-
-exit_code=0
-
-# If there is no symbol in the object, ${NM} (both GNU nm and llvm-nm) shows
-# 'no symbols' diagnostic (but exits with 0). It is harmless and hidden by
-# '2>/dev/null'. However, it suppresses real error messages as well. Add a
-# hand-crafted error message here.
-#
-# TODO:
-# Use --quiet instead of 2>/dev/null when we upgrade the minimum version of
-# binutils to 2.37, llvm to 13.0.0.
-# Then, the following line will be really simple:
-#   ${NM} --quiet ${1} |
-
-{ ${NM} ${1} 2>/dev/null || { echo "${0}: ${NM} failed" >&2; false; } } |
-while read value type name
-do
-	# Skip the line if the number of fields is less than 3.
-	#
-	# case 1)
-	#   For undefined symbols, the first field (value) is empty.
-	#   The outout looks like this:
-	#     "                 U _printk"
-	#   It is unneeded to record undefined symbols.
-	#
-	# case 2)
-	#   For Clang LTO, llvm-nm outputs a line with type 't' but empty name:
-	#     "---------------- t"
-	if [[ -z ${name} ]]; then
-		continue
-	fi
-
-	# save (name, type) in the associative array
-	symbol_types[${name}]=${type}
-
-	# append the exported symbol to the array
-	if [[ ${name} == __ksymtab_* ]]; then
-		export_symbols+=(${name#__ksymtab_})
-	fi
-done
-
-for name in "${export_symbols[@]}"
-do
-	# nm(3) says "If lowercase, the symbol is usually local"
-	if [[ ${symbol_types[$name]} =~ [a-z] ]]; then
-		echo "$@: error: local symbol '${name}' was exported" >&2
-		exit_code=1
-	fi
-done
-
-exit ${exit_code}
diff -uraN a/scripts/mod/modpost.c b/scripts/mod/modpost.c
--- a/scripts/mod/modpost.c	2022-08-01 00:03:01.000000000 +0300
+++ b/scripts/mod/modpost.c	2022-08-03 22:25:07.856325468 +0300
@@ -214,6 +214,7 @@
 	unsigned int crc;
 	bool crc_valid;
 	bool weak;
+	bool is_static;		/* true if symbol is not global */
 	bool is_gpl_only;	/* exported by EXPORT_SYMBOL_GPL */
 	char name[];
 };
@@ -243,7 +244,7 @@
 
 	memset(s, 0, sizeof(*s));
 	strcpy(s->name, name);
-
+	s->is_static = true;
 	return s;
 }
 
@@ -2014,6 +2015,20 @@
 					     sym_get_data(&info, sym));
 	}
 
+	// check for static EXPORT_SYMBOL_* functions && global vars
+	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
+		unsigned char bind = ELF_ST_BIND(sym->st_info);
+
+		if (bind == STB_GLOBAL || bind == STB_WEAK) {
+			struct symbol *s =
+				find_symbol(remove_dot(info.strtab +
+						       sym->st_name));
+
+			if (s)
+				s->is_static = false;
+		}
+	}
+
 	check_sec_ref(modname, &info);
 
 	if (!mod->is_vmlinux) {
@@ -2443,6 +2458,7 @@
 			mod->from_dump = true;
 		}
 		s = sym_add_exported(symname, mod, gpl_only);
+		s->is_static = false;
 		sym_set_crc(s, crc);
 		sym_update_namespace(symname, namespace);
 	}
@@ -2507,6 +2523,7 @@
 	char *missing_namespace_deps = NULL;
 	char *dump_write = NULL, *files_source = NULL;
 	int opt;
+	int n;
 	LIST_HEAD(dump_lists);
 	struct dump_list *dl, *dl2;
 
@@ -2582,6 +2599,15 @@
 	if (sec_mismatch_count && !sec_mismatch_warn_only)
 		error("Section mismatches detected.\n"
 		      "Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.\n");
+	for (n = 0; n < SYMBOL_HASH_SIZE; n++) {
+		struct symbol *s;
+
+		for (s = symbolhash[n]; s; s = s->next) {
+			if (s->is_static)
+				error("\"%s\" [%s] is a static EXPORT_SYMBOL\n",
+				      s->name, s->module->name);
+		}
+	}
 
 	if (nr_unresolved > MAX_UNRESOLVED_REPORTS)
 		warn("suppressed %u unresolved symbol warnings because there were too many)\n",
